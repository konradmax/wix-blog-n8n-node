export interface Category {
    /** Category ID. */
    _id?: string;
    /** Category label. Displayed in the Category Menu. */
    label?: string;
    /**
     * Number of posts in the category.
     * @readonly
     */
    postCount?: number;
    /**
     * The `url` of the page that lists every post with the specified category.
     * @readonly
     */
    url?: string;
    /** Category description. */
    description?: string | null;
    /**
     * Category title.
     * @deprecated Category title.
     * @targetRemovalDate 2025-07-16
     */
    title?: string;
    /**
     * Position of the category in the [Category Menu](https://support.wix.com/en/article/wix-blog-adding-and-customizing-a-category-menu).
     * Categories are displayed in ascending order. Categories with a position of `-1` appear at the end of the sequence.
     *
     * Default: `-1`
     */
    displayPosition?: number | null;
    /** ID of the category's translations. All translations of a single category share the same `translationId`. */
    translationId?: string | null;
    /**
     * Category language.
     *
     * 2-or-4-letter language code in [IETF BCP 47 language tag](https://en.wikipedia.org/wiki/IETF_language_tag) format.
     */
    language?: string | null;
    /** Part of a category's URL that refers to a specific category. For example, the slug of `https:/example.com/blog/category/famous-cats` is `famous-cats`. */
    slug?: string;
    /**
     * Reserved for internal use.
     * @readonly
     */
    internalId?: string | null;
    /** SEO data. */
    seoData?: SeoSchema;
    /** Category cover image. */
    coverImage?: string;
    /**
     * Date and time the Category was last updated.
     * @readonly
     */
    _updatedDate?: Date | null;
}
/**
 * The SEO schema object contains data about different types of meta tags. It makes sure that the information about your page is presented properly to search engines.
 * The search engines use this information for ranking purposes, or to display snippets in the search results.
 * This data will override other sources of tags (for example patterns) and will be included in the <head> section of the HTML document, while not being displayed on the page itself.
 */
export interface SeoSchema {
    /** SEO tag information. */
    tags?: Tag[];
    /** SEO general settings. */
    settings?: Settings;
}
export interface Keyword {
    /** Keyword value. */
    term?: string;
    /** Whether the keyword is the main focus keyword. */
    isMain?: boolean;
    /** The source that added the keyword terms to the SEO settings. */
    origin?: string | null;
}
export interface Tag {
    /**
     * SEO tag type.
     *
     *
     * Supported values: `title`, `meta`, `script`, `link`.
     */
    type?: string;
    /**
     * A `{"key": "value"}` pair object where each SEO tag property (`"name"`, `"content"`, `"rel"`, `"href"`) contains a value.
     * For example: `{"name": "description", "content": "the description itself"}`.
     */
    props?: Record<string, any> | null;
    /** SEO tag meta data. For example, `{"height": 300, "width": 240}`. */
    meta?: Record<string, any> | null;
    /** SEO tag inner content. For example, `<title> inner content </title>`. */
    children?: string;
    /** Whether the tag is a custom tag. */
    custom?: boolean;
    /** Whether the tag is disabled. */
    disabled?: boolean;
}
export interface Settings {
    /**
     * Whether the Auto Redirect feature, which creates `301 redirects` on a slug change, is enabled.
     *
     *
     * Default: `false` (Auto Redirect is enabled.)
     */
    preventAutoRedirect?: boolean;
    /** User-selected keyword terms for a specific page. */
    keywords?: Keyword[];
}
export interface FocalPoint {
    /** X-coordinate of the focal point. */
    x?: number;
    /** Y-coordinate of the focal point. */
    y?: number;
    /** crop by height */
    height?: number | null;
    /** crop by width */
    width?: number | null;
}
export interface CategoryTranslation {
    /** Category ID. */
    _id?: string;
    /** Label displayed in the categories menu on the site. */
    label?: string | null;
    /** Language of the category. */
    language?: string | null;
    /** URL of this category page. */
    url?: string;
}
export interface InitialCategoriesCopied {
    /** Number of categories copied. */
    count?: number;
}
export interface CreateCategoryRequest {
    /** Category info. */
    category: Category;
    /**
     * List of additional category fields to include in the response. By default
     * only the category’s base fields are returned. Base fields are all category fields that don't appear in the fieldset enum.
     *
     * To retrieve a field, pass the relevant fieldset in the enum in the `fieldsets` array. For example, add the `URL` fieldset to `fieldsets` to
     * retrieve the url field in the response in addition to the category’s base fields.
     */
    fieldsets?: Field[];
}
export declare enum Field {
    UNKNOWN = "UNKNOWN",
    /** Includes Category url. */
    URL = "URL",
    /**
     * Includes internal id field.
     * Reserved for internal use
     */
    INTERNAL_ID = "INTERNAL_ID",
    /** Includes SEO data. */
    SEO = "SEO"
}
export interface CreateCategoryResponse {
    /** Category info. */
    category?: Category;
}
export interface BulkCreateCategoriesRequest {
    /** Categories to create. */
    categories?: Category[];
    /** Whether to return the full created category entities in the response. */
    returnFullEntity?: boolean;
    /**
     * List of additional category fields to include in the response. By default
     * only the category’s base fields are returned. Base fields are all category fields that don't appear in the fieldset enum.
     *
     * To retrieve a field, pass the relevant fieldset in the enum in the `fieldsets` array. For example, add the `URL` fieldset to `fieldsets` to
     * retrieve the url field in the response in addition to the category’s base fields.
     */
    fieldsets?: Field[];
}
export interface BulkCreateCategoriesResponse {
    /** Categories created by bulk action. */
    results?: BulkCategoryResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata;
}
export interface BulkCategoryResult {
    /** Bulk actions metadata for category. */
    itemMetadata?: ItemMetadata;
    /** Optional created category. */
    item?: Category;
}
export interface ItemMetadata {
    /** Item ID. Should always be available, unless it's impossible (for example, when failing to create an item). */
    _id?: string | null;
    /** Index of the item within the request array. Allows for correlation between request and response items. */
    originalIndex?: number;
    /** Whether the requested action was successful for this item. When `false`, the `error` field is populated. */
    success?: boolean;
    /** Details about the error in case of failure. */
    error?: ApplicationError;
}
export interface ApplicationError {
    /** Error code. */
    code?: string;
    /** Description of the error. */
    description?: string;
    /** Data related to the error. */
    data?: Record<string, any> | null;
}
export interface BulkActionMetadata {
    /** Number of items that were successfully processed. */
    totalSuccesses?: number;
    /** Number of items that couldn't be processed. */
    totalFailures?: number;
    /** Number of failures without details because detailed failure threshold was exceeded. */
    undetailedFailures?: number;
}
export interface BulkUpdateCategoriesRequest {
    /** Categories to update. */
    categories?: MaskedCategory[];
    /** Whether to return the full created category entities in the response. */
    returnFullEntity?: boolean;
    /**
     * List of additional category fields to include in the response. By default
     * only the category’s base fields are returned. Base fields are all category fields that don't appear in the fieldset enum.
     *
     * To retrieve a field, pass the relevant fieldset in the enum in the `fieldsets` array. For example, add the `URL` fieldset to `fieldsets` to
     * retrieve the url field in the response in addition to the category’s base fields.
     */
    fieldsets?: Field[];
}
export interface MaskedCategory {
    /** Category */
    category?: Category;
    /** Field mask of fields to update. */
    fieldMask?: string[];
}
export interface BulkUpdateCategoriesResponse {
    /** Categories updated by bulk action. */
    results?: BulkCategoryResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata;
}
export interface UpdateCategoryRequest {
    /** Category info. */
    category: Category;
    /**
     * List of additional category fields to include in the response. By default
     * only the category’s base fields are returned. Base fields are all category fields that don't appear in the fieldset enum.
     *
     * To retrieve a field, pass the relevant fieldset in the enum in the `fieldsets` array. For example, add the `URL` fieldset to `fieldsets` to
     * retrieve the url field in the response in addition to the category’s base fields.
     */
    fieldsets?: Field[];
}
export interface UpdateCategoryResponse {
    /** Category info. */
    category?: Category;
}
export interface GetCategoriesCountByLanguageRequest {
}
export interface GetCategoriesCountByLanguageResponse {
    /** The language and it's count. */
    categoriesLanguageCount?: CategoryLanguageCount[];
}
export interface CategoryLanguageCount {
    /** 2-or-4-letter language code in [IETF BCP 47 language tag](https://en.wikipedia.org/wiki/IETF_language_tag) format. */
    languageCode?: string | null;
    /** The count of Categories for the language. */
    categoryCount?: number | null;
}
export interface GetCategoryRequest {
    /** Category ID. */
    categoryId: string;
    /**
     * List of additional category fields to include in the response. By default
     * only the category’s base fields are returned. Base fields are all category fields that don't appear in the fieldset enum.
     *
     * To retrieve a field, pass the relevant fieldset in the enum in the `fieldsets` array. For example, add the `URL` fieldset to `fieldsets` to
     * retrieve the url field in the response in addition to the category’s base fields.
     */
    fieldsets?: Field[];
}
export interface GetCategoryResponse {
    /** Category info. */
    category?: Category;
}
export interface GetCategoryBySlugRequest {
    /** Slug of the category to retrieve. */
    slug: string;
    /**
     * List of additional category fields to include in the response. By default
     * only the category’s base fields are returned. Base fields are all category fields that don't appear in the fieldset enum.
     *
     * To retrieve a field, pass the relevant fieldset in the enum in the `fieldsets` array. For example, add the `URL` fieldset to `fieldsets` to
     * retrieve the url field in the response in addition to the category’s base fields.
     */
    fieldsets?: Field[];
    /**
     * 2-or-4-letter language code in [IETF BCP 47 language tag](https://en.wikipedia.org/wiki/IETF_language_tag) format.
     * Language of the category to retrieve.
     */
    language?: string | null;
}
export interface GetCategoryBySlugResponse {
    /** Category info. */
    category?: Category;
}
export interface ListCategoriesRequest {
    /** Pagination options. */
    paging?: BlogPaging;
    /**
     * List of additional category fields to include in the response. By default
     * only the category’s base fields are returned. Base fields are all category fields that don't appear in the fieldset enum.
     *
     * To retrieve a field, pass the relevant fieldset in the enum in the `fieldsets` array. For example, add the `URL` fieldset to `fieldsets` to
     * retrieve the url field in the response in addition to the category’s base fields.
     */
    fieldsets?: Field[];
    /**
     * Language filter.
     *
     * 2-or-4-letter language code in [IETF BCP 47 language tag](https://en.wikipedia.org/wiki/IETF_language_tag) format.
     * Pass a language to only receive categories that are in that language.
     * If omitted, categories in all languages are returned.
     */
    language?: string | null;
}
export interface BlogPaging {
    /**
     * Number of items to skip in the current sort order.
     *
     *
     * Default: `0`
     */
    offset?: number;
    /**
     * Number of items to return.
     *
     * Default: `50`
     *
     * Max: `100`
     */
    limit?: number;
    /** Pointer to the next or previous page in the list of results. */
    cursor?: string | null;
}
export interface ListCategoriesResponse {
    /** List of categories. */
    categories?: Category[];
    /** Details on the paged set of results returned. */
    metaData?: MetaData;
}
export interface MetaData {
    /** Number of items returned in this response. */
    count?: number;
    /** Requested offset. */
    offset?: number;
    /** Total number of items that match the query. */
    total?: number;
    /** Pointer to the next or previous page in the list of results. */
    cursor?: string | null;
}
export interface QueryCategoriesRequest {
    /** Query options. */
    query?: PlatformQuery;
    /**
     * List of additional category fields to include in the response. By default
     * only the category’s base fields are returned. Base fields are all category fields that don't appear in the fieldset enum.
     *
     * To retrieve a field, pass the relevant fieldset in the enum in the `fieldsets` array. For example, add the `URL` fieldset to `fieldsets` to
     * retrieve the url field in the response in addition to the category’s base fields.
     */
    fieldsets?: Field[];
}
export interface PlatformQuery extends PlatformQueryPagingMethodOneOf {
    /** Paging options to limit and skip the number of items. */
    paging?: Paging;
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CursorPaging;
    /**
     * Filter object in the following format:
     * `"filter" : {
     * "fieldName1": "value1",
     * "fieldName2":{"$operator":"value2"}
     * }`
     * Example of operators: `$eq`, `$ne`, `$lt`, `$lte`, `$gt`, `$gte`, `$in`, `$hasSome`, `$hasAll`, `$startsWith`, `$contains`
     */
    filter?: Record<string, any> | null;
    /**
     * Sort object in the following format:
     * `[{"fieldName":"sortField1","order":"ASC"},{"fieldName":"sortField2","order":"DESC"}]`
     */
    sort?: Sorting[];
}
/** @oneof */
export interface PlatformQueryPagingMethodOneOf {
    /** Paging options to limit and skip the number of items. */
    paging?: Paging;
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CursorPaging;
}
export interface Sorting {
    /** Name of the field to sort by. */
    fieldName?: string;
    /** Sort order. */
    order?: SortOrder;
}
export declare enum SortOrder {
    ASC = "ASC",
    DESC = "DESC"
}
export interface Paging {
    /** Number of items to load. */
    limit?: number | null;
    /** Number of items to skip in the current sort order. */
    offset?: number | null;
}
export interface CursorPaging {
    /** Number of items to load. */
    limit?: number | null;
    /**
     * Pointer to the next or previous page in the list of results.
     *
     * You can get the relevant cursor token
     * from the `pagingMetadata` object in the previous call's response.
     * Not relevant for the first request.
     */
    cursor?: string | null;
}
export interface QueryCategoriesResponse {
    /** List of categories. */
    categories?: Category[];
    /** Details on the paged set of results returned. */
    pagingMetadata?: PagingMetadataV2;
}
export interface PagingMetadataV2 {
    /** Number of items returned in the response. */
    count?: number | null;
    /** Offset that was requested. */
    offset?: number | null;
    /** Total number of items that match the query. Returned if offset paging is used and the `tooManyToCount` flag is not set. */
    total?: number | null;
    /** Flag that indicates the server failed to calculate the `total` field. */
    tooManyToCount?: boolean | null;
    /** Cursors to navigate through the result pages using `next` and `prev`. Returned if cursor paging is used. */
    cursors?: Cursors;
}
export interface Cursors {
    /** Cursor pointing to next page in the list of results. */
    next?: string | null;
    /** Cursor pointing to previous page in the list of results. */
    prev?: string | null;
}
export interface BulkDeleteCategoryRequest {
    /** Category IDs. */
    categoryIds?: string[];
    /** Should delete bypassing the trash-bin. */
    permanent?: boolean;
}
export interface BulkDeleteCategoryResponse {
}
export interface DeleteCategoryRequest {
    /** Category ID. */
    categoryId: string;
}
export interface DeleteCategoryResponse {
}
export interface DomainEvent extends DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
    /**
     * Unique event ID.
     * Allows clients to ignore duplicate webhooks.
     */
    _id?: string;
    /**
     * Assumes actions are also always typed to an entity_type
     * Example: wix.stores.catalog.product, wix.bookings.session, wix.payments.transaction
     */
    entityFqdn?: string;
    /**
     * This is top level to ease client code dispatching of messages (switch on entity_fqdn+slug)
     * This is although the created/updated/deleted notion is duplication of the oneof types
     * Example: created/updated/deleted/started/completed/email_opened
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example: 2020-04-26T13:57:50.699Z */
    eventTime?: Date | null;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number defining the order of updates to the underlying entity.
     * For example, given that some entity was updated at 16:00 and than again at 16:01,
     * it is guaranteed that the sequence number of the second update is strictly higher than the first.
     * As the consumer, you can use this value to ensure that you handle messages in the correct order.
     * To do so, you will need to persist this number on your end, and compare the sequence number from the
     * message against the one you have stored. Given that the stored number is higher, you should ignore the message.
     */
    entityEventSequence?: string | null;
}
/** @oneof */
export interface DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
}
export interface EntityCreatedEvent {
    entity?: string;
}
export interface RestoreInfo {
    deletedDate?: Date | null;
}
export interface EntityUpdatedEvent {
    /**
     * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
     * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
     * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
     */
    currentEntity?: string;
}
export interface EntityDeletedEvent {
    /** Entity that was deleted */
    deletedEntity?: string | null;
}
export interface ActionEvent {
    body?: string;
}
export interface MessageEnvelope {
    /** App instance ID. */
    instanceId?: string | null;
    /** Event type. */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
    /** Stringify payload. */
    data?: string;
}
export interface IdentificationData extends IdentificationDataIdOneOf {
    /** ID of a site visitor that has not logged in to the site. */
    anonymousVisitorId?: string;
    /** ID of a site visitor that has logged in to the site. */
    memberId?: string;
    /** ID of a Wix user (site owner, contributor, etc.). */
    wixUserId?: string;
    /** ID of an app. */
    appId?: string;
    /** @readonly */
    identityType?: WebhookIdentityType;
}
/** @oneof */
export interface IdentificationDataIdOneOf {
    /** ID of a site visitor that has not logged in to the site. */
    anonymousVisitorId?: string;
    /** ID of a site visitor that has logged in to the site. */
    memberId?: string;
    /** ID of a Wix user (site owner, contributor, etc.). */
    wixUserId?: string;
    /** ID of an app. */
    appId?: string;
}
export declare enum WebhookIdentityType {
    UNKNOWN = "UNKNOWN",
    ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
    MEMBER = "MEMBER",
    WIX_USER = "WIX_USER",
    APP = "APP"
}
interface TagNonNullableFields {
    type: string;
    children: string;
    custom: boolean;
    disabled: boolean;
}
interface KeywordNonNullableFields {
    term: string;
    isMain: boolean;
}
interface SettingsNonNullableFields {
    preventAutoRedirect: boolean;
    keywords: KeywordNonNullableFields[];
}
interface SeoSchemaNonNullableFields {
    tags: TagNonNullableFields[];
    settings?: SettingsNonNullableFields;
}
interface CategoryTranslationNonNullableFields {
    _id: string;
    url: string;
}
export interface CategoryNonNullableFields {
    _id: string;
    label: string;
    postCount: number;
    url: string;
    title: string;
    slug: string;
    seoData?: SeoSchemaNonNullableFields;
    coverImage: string;
    translations: CategoryTranslationNonNullableFields[];
}
export interface CreateCategoryResponseNonNullableFields {
    category?: CategoryNonNullableFields;
}
export interface UpdateCategoryResponseNonNullableFields {
    category?: CategoryNonNullableFields;
}
export interface GetCategoryResponseNonNullableFields {
    category?: CategoryNonNullableFields;
}
export interface GetCategoryBySlugResponseNonNullableFields {
    category?: CategoryNonNullableFields;
}
interface MetaDataNonNullableFields {
    count: number;
    offset: number;
    total: number;
}
export interface ListCategoriesResponseNonNullableFields {
    categories: CategoryNonNullableFields[];
    metaData?: MetaDataNonNullableFields;
}
export interface QueryCategoriesResponseNonNullableFields {
    categories: CategoryNonNullableFields[];
}
export interface BaseEventMetadata {
    /** App instance ID. */
    instanceId?: string | null;
    /** Event type. */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
}
export interface EventMetadata extends BaseEventMetadata {
    /**
     * Unique event ID.
     * Allows clients to ignore duplicate webhooks.
     */
    _id?: string;
    /**
     * Assumes actions are also always typed to an entity_type
     * Example: wix.stores.catalog.product, wix.bookings.session, wix.payments.transaction
     */
    entityFqdn?: string;
    /**
     * This is top level to ease client code dispatching of messages (switch on entity_fqdn+slug)
     * This is although the created/updated/deleted notion is duplication of the oneof types
     * Example: created/updated/deleted/started/completed/email_opened
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example: 2020-04-26T13:57:50.699Z */
    eventTime?: Date | null;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number defining the order of updates to the underlying entity.
     * For example, given that some entity was updated at 16:00 and than again at 16:01,
     * it is guaranteed that the sequence number of the second update is strictly higher than the first.
     * As the consumer, you can use this value to ensure that you handle messages in the correct order.
     * To do so, you will need to persist this number on your end, and compare the sequence number from the
     * message against the one you have stored. Given that the stored number is higher, you should ignore the message.
     */
    entityEventSequence?: string | null;
}
export interface CategoryCreatedEnvelope {
    entity: Category;
    metadata: EventMetadata;
}
/**
 * Triggered when a category is created.
 * @permissionScope Read Blog
 * @permissionScopeId SCOPE.DC-BLOG.READ-BLOGS
 * @permissionScope Manage Blog
 * @permissionScopeId SCOPE.DC-BLOG.MANAGE-BLOG
 * @permissionScope Read Draft Blog Posts
 * @permissionScopeId SCOPE.DC-BLOG.READ-DRAFT-POSTS
 * @permissionId BLOG.READ-CATEGORY
 * @webhook
 * @eventType wix.blog.v3.category_created
 * @serviceIdentifier com.wixpress.npm.communities.platformized.blog.v3.CategoryService
 * @slug created
 */
export declare function onCategoryCreated(handler: (event: CategoryCreatedEnvelope) => void | Promise<void>): void;
export interface CategoryDeletedEnvelope {
    metadata: EventMetadata;
}
/**
 * Triggered when a category is deleted.
 * @permissionScope Read Blog
 * @permissionScopeId SCOPE.DC-BLOG.READ-BLOGS
 * @permissionScope Manage Blog
 * @permissionScopeId SCOPE.DC-BLOG.MANAGE-BLOG
 * @permissionScope Read Draft Blog Posts
 * @permissionScopeId SCOPE.DC-BLOG.READ-DRAFT-POSTS
 * @permissionId BLOG.READ-CATEGORY
 * @webhook
 * @eventType wix.blog.v3.category_deleted
 * @serviceIdentifier com.wixpress.npm.communities.platformized.blog.v3.CategoryService
 * @slug deleted
 */
export declare function onCategoryDeleted(handler: (event: CategoryDeletedEnvelope) => void | Promise<void>): void;
export interface CategoryUpdatedEnvelope {
    entity: Category;
    metadata: EventMetadata;
}
/**
 * Triggered when a category is updated.
 * @permissionScope Read Blog
 * @permissionScopeId SCOPE.DC-BLOG.READ-BLOGS
 * @permissionScope Manage Blog
 * @permissionScopeId SCOPE.DC-BLOG.MANAGE-BLOG
 * @permissionScope Read Draft Blog Posts
 * @permissionScopeId SCOPE.DC-BLOG.READ-DRAFT-POSTS
 * @permissionId BLOG.READ-CATEGORY
 * @webhook
 * @eventType wix.blog.v3.category_updated
 * @serviceIdentifier com.wixpress.npm.communities.platformized.blog.v3.CategoryService
 * @slug updated
 */
export declare function onCategoryUpdated(handler: (event: CategoryUpdatedEnvelope) => void | Promise<void>): void;
/**
 * Creates a category.
 * @param category - Category info.
 * @public
 * @requiredField category
 * @requiredField category.label
 * @permissionId BLOG.CREATE-CATEGORY
 * @permissionScope Manage Blog
 * @permissionScopeId SCOPE.DC-BLOG.MANAGE-BLOG
 * @applicableIdentity APP
 * @returns Category info.
 * @fqn com.wixpress.npm.communities.platformized.blog.v3.CategoryService.CreateCategory
 */
export declare function createCategory(category: Category, options?: CreateCategoryOptions): Promise<Category & CategoryNonNullableFields>;
export interface CreateCategoryOptions {
    /**
     * List of additional category fields to include in the response. By default
     * only the category’s base fields are returned. Base fields are all category fields that don't appear in the fieldset enum.
     *
     * To retrieve a field, pass the relevant fieldset in the enum in the `fieldsets` array. For example, add the `URL` fieldset to `fieldsets` to
     * retrieve the url field in the response in addition to the category’s base fields.
     */
    fieldsets?: Field[];
}
/**
 * Updates a category.
 * @param _id - Category ID.
 * @public
 * @requiredField _id
 * @requiredField category
 * @permissionId BLOG.EDIT-CATEGORY
 * @permissionScope Manage Blog
 * @permissionScopeId SCOPE.DC-BLOG.MANAGE-BLOG
 * @applicableIdentity APP
 * @returns Category info.
 * @fqn com.wixpress.npm.communities.platformized.blog.v3.CategoryService.UpdateCategory
 */
export declare function updateCategory(_id: string, category: UpdateCategory, options?: UpdateCategoryOptions): Promise<Category & CategoryNonNullableFields>;
export interface UpdateCategory {
    /** Category ID. */
    _id?: string;
    /** Category label. Displayed in the Category Menu. */
    label?: string;
    /**
     * Number of posts in the category.
     * @readonly
     */
    postCount?: number;
    /**
     * The `url` of the page that lists every post with the specified category.
     * @readonly
     */
    url?: string;
    /** Category description. */
    description?: string | null;
    /**
     * Category title.
     * @deprecated Category title.
     * @targetRemovalDate 2025-07-16
     */
    title?: string;
    /**
     * Position of the category in the [Category Menu](https://support.wix.com/en/article/wix-blog-adding-and-customizing-a-category-menu).
     * Categories are displayed in ascending order. Categories with a position of `-1` appear at the end of the sequence.
     *
     * Default: `-1`
     */
    displayPosition?: number | null;
    /** ID of the category's translations. All translations of a single category share the same `translationId`. */
    translationId?: string | null;
    /**
     * Category language.
     *
     * 2-or-4-letter language code in [IETF BCP 47 language tag](https://en.wikipedia.org/wiki/IETF_language_tag) format.
     */
    language?: string | null;
    /** Part of a category's URL that refers to a specific category. For example, the slug of `https:/example.com/blog/category/famous-cats` is `famous-cats`. */
    slug?: string;
    /**
     * Reserved for internal use.
     * @readonly
     */
    internalId?: string | null;
    /** SEO data. */
    seoData?: SeoSchema;
    /** Category cover image. */
    coverImage?: string;
    /**
     * Date and time the Category was last updated.
     * @readonly
     */
    _updatedDate?: Date | null;
}
export interface UpdateCategoryOptions {
    /**
     * List of additional category fields to include in the response. By default
     * only the category’s base fields are returned. Base fields are all category fields that don't appear in the fieldset enum.
     *
     * To retrieve a field, pass the relevant fieldset in the enum in the `fieldsets` array. For example, add the `URL` fieldset to `fieldsets` to
     * retrieve the url field in the response in addition to the category’s base fields.
     */
    fieldsets?: Field[];
}
/**
 * Gets a category with the specified ID.
 * @param categoryId - Category ID.
 * @public
 * @requiredField categoryId
 * @param options - Options specifying which fields to return.
 * @permissionId BLOG.READ-CATEGORY
 * @permissionScope Read Blog
 * @permissionScopeId SCOPE.DC-BLOG.READ-BLOGS
 * @permissionScope Manage Blog
 * @permissionScopeId SCOPE.DC-BLOG.MANAGE-BLOG
 * @permissionScope Read Draft Blog Posts
 * @permissionScopeId SCOPE.DC-BLOG.READ-DRAFT-POSTS
 * @applicableIdentity APP
 * @applicableIdentity VISITOR
 * @fqn com.wixpress.npm.communities.platformized.blog.v3.CategoryService.GetCategory
 */
export declare function getCategory(categoryId: string, options?: GetCategoryOptions): Promise<GetCategoryResponse & GetCategoryResponseNonNullableFields>;
export interface GetCategoryOptions {
    /**
     * List of additional category fields to include in the response. By default
     * only the category’s base fields are returned. Base fields are all category fields that don't appear in the fieldset enum.
     *
     * To retrieve a field, pass the relevant fieldset in the enum in the `fieldsets` array. For example, add the `URL` fieldset to `fieldsets` to
     * retrieve the url field in the response in addition to the category’s base fields.
     */
    fieldsets?: Field[];
}
/**
 * Gets a category with the specified slug.
 *
 * The slug is at the end of the URL of a specific category.
 * For example, if a category's URL is `https://example.com/blog/categories/famous-cats`, the slug is `famous-cats`.
 * The slug is a case-sensitive string that is derived from the category's label, unless specified otherwise.
 * @public
 * @requiredField slug
 * @param slug - Slug of the category to retrieve.
 *
 * The end of a category's URL. For example, `'https:/example.com/blog/category/{my-category-slug}'`. Case sensitive and generally based on the category `label` if not specified.
 * @param options - Options specifying which fields to return.
 * @permissionId BLOG.READ-CATEGORY
 * @permissionScope Read Blog
 * @permissionScopeId SCOPE.DC-BLOG.READ-BLOGS
 * @permissionScope Manage Blog
 * @permissionScopeId SCOPE.DC-BLOG.MANAGE-BLOG
 * @permissionScope Read Draft Blog Posts
 * @permissionScopeId SCOPE.DC-BLOG.READ-DRAFT-POSTS
 * @applicableIdentity APP
 * @applicableIdentity VISITOR
 * @fqn com.wixpress.npm.communities.platformized.blog.v3.CategoryService.GetCategoryBySlug
 */
export declare function getCategoryBySlug(slug: string, options?: GetCategoryBySlugOptions): Promise<GetCategoryBySlugResponse & GetCategoryBySlugResponseNonNullableFields>;
export interface GetCategoryBySlugOptions {
    /**
     * List of additional category fields to include in the response. By default
     * only the category’s base fields are returned. Base fields are all category fields that don't appear in the fieldset enum.
     *
     * To retrieve a field, pass the relevant fieldset in the enum in the `fieldsets` array. For example, add the `URL` fieldset to `fieldsets` to
     * retrieve the url field in the response in addition to the category’s base fields.
     */
    fieldsets?: Field[];
    /**
     * 2-or-4-letter language code in [IETF BCP 47 language tag](https://en.wikipedia.org/wiki/IETF_language_tag) format.
     * Language of the category to retrieve.
     */
    language?: string | null;
}
/**
 * Retrieves a list of up to 100 categories per request.
 *
 * If you pass a language filter to the method, it returns a list of up to 100 categories in the requested language.
 *
 * The categoies are displayed in order of their `displayPosition`, starting with `0`. The `displayPosition` is the position in which the categories
 * are displayed in the Category Menu page. By default, categories get added to the bottom of the Category Menu page with a `displayPosition` of `-1`.
 *
 * List Categories runs with these defaults, which you can override:
 * - `paging.limit` is `50`.
 * - `paging.offset` is `0`.
 *
 * List Categories is sorted by `displayPosition` in descending order. This cannot be overridden.
 * @public
 * @param options - Filter and paging options.
 * @permissionId BLOG.READ-CATEGORY
 * @permissionScope Read Blog
 * @permissionScopeId SCOPE.DC-BLOG.READ-BLOGS
 * @permissionScope Manage Blog
 * @permissionScopeId SCOPE.DC-BLOG.MANAGE-BLOG
 * @permissionScope Read Draft Blog Posts
 * @permissionScopeId SCOPE.DC-BLOG.READ-DRAFT-POSTS
 * @applicableIdentity APP
 * @applicableIdentity VISITOR
 * @fqn com.wixpress.npm.communities.platformized.blog.v3.CategoryService.ListCategories
 */
export declare function listCategories(options?: ListCategoriesOptions): Promise<ListCategoriesResponse & ListCategoriesResponseNonNullableFields>;
export interface ListCategoriesOptions {
    /** Pagination options. */
    paging?: BlogPaging;
    /**
     * List of additional category fields to include in the response. By default
     * only the category’s base fields are returned. Base fields are all category fields that don't appear in the fieldset enum.
     *
     * To retrieve a field, pass the relevant fieldset in the enum in the `fieldsets` array. For example, add the `URL` fieldset to `fieldsets` to
     * retrieve the url field in the response in addition to the category’s base fields.
     */
    fieldsets?: Field[];
    /**
     * Language filter.
     *
     * 2-or-4-letter language code in [IETF BCP 47 language tag](https://en.wikipedia.org/wiki/IETF_language_tag) format.
     * Pass a language to only receive categories that are in that language.
     * If omitted, categories in all languages are returned.
     */
    language?: string | null;
}
/**
 * Creates a query to retrieve a list of categories.
 *
 *
 * The Query Categories method builds a query to retrieve a list of up to 100 categories per language, and returns a [`CategoriesQueryBuilder`](https://dev.wix.com/docs/sdk/backend-modules/blog/categories/categories-query-builder/ascending) object.
 *
 * The response contains the query definition, which is typically used to run the query using the [`find()`](https://dev.wix.com/docs/sdk/backend-modules/blog/categories/categories-query-builder/find) method.
 *
 * You can refine the query by chaining `CategoriesQueryBuilder` methods to the query. `CategoriesQueryBuilder` methods enable you to sort, filter, and control the results that Query Categories returns. Any methods chained to the Query Categories method are applied in the order that they are called.
 *
 * Query Categories runs with these `CategoriesQueryBuilder` defaults, which you can override.
 * - [`limit(100)`](https://dev.wix.com/docs/sdk/backend-modules/blog/categories/categories-query-builder/limit)
 * - [`ascending(displayPosition)`](https://dev.wix.com/docs/sdk/backend-modules/blog/categories/categories-query-builder/ascending)
 *
 * The following `CategoriesQueryBuilder` methods are supported for Query Categories. For a full description of the `Categories` object, see the response for the [`items`](https://dev.wix.com/docs/sdk/backend-modules/blog/categories/categories-query-result/items) property in [`CategoriesQueryResult`](https://www.wix.com/velo/reference/wix-blog-backend/categories/categoriesqueryresult).
 * @public
 * @param options - Options specifying which fields to return.
 * @permissionScope Read Blog
 * @permissionScopeId SCOPE.DC-BLOG.READ-BLOGS
 * @permissionScope Manage Blog
 * @permissionScopeId SCOPE.DC-BLOG.MANAGE-BLOG
 * @permissionScope Read Draft Blog Posts
 * @permissionScopeId SCOPE.DC-BLOG.READ-DRAFT-POSTS
 * @permissionId BLOG.READ-CATEGORY
 * @applicableIdentity APP
 * @applicableIdentity VISITOR
 * @fqn com.wixpress.npm.communities.platformized.blog.v3.CategoryService.QueryCategories
 */
export declare function queryCategories(options?: QueryCategoriesOptions): CategoriesQueryBuilder;
export interface QueryCategoriesOptions {
    /**  */
    fieldsets?: Field[] | undefined;
}
interface QueryOffsetResult {
    currentPage: number | undefined;
    totalPages: number | undefined;
    totalCount: number | undefined;
    hasNext: () => boolean;
    hasPrev: () => boolean;
    length: number;
    pageSize: number;
}
export interface CategoriesQueryResult extends QueryOffsetResult {
    items: Category[];
    query: CategoriesQueryBuilder;
    next: () => Promise<CategoriesQueryResult>;
    prev: () => Promise<CategoriesQueryResult>;
}
export interface CategoriesQueryBuilder {
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     */
    eq: (propertyName: '_id' | 'label' | 'postCount' | 'title' | 'displayPosition' | 'translationId' | 'language' | 'slug' | 'internalId', value: any) => CategoriesQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     */
    ne: (propertyName: '_id' | 'label' | 'postCount' | 'title' | 'displayPosition' | 'translationId' | 'language' | 'slug' | 'internalId', value: any) => CategoriesQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     */
    ge: (propertyName: 'postCount' | 'displayPosition', value: any) => CategoriesQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     */
    gt: (propertyName: 'postCount' | 'displayPosition', value: any) => CategoriesQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     */
    le: (propertyName: 'postCount' | 'displayPosition', value: any) => CategoriesQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     */
    lt: (propertyName: 'postCount' | 'displayPosition', value: any) => CategoriesQueryBuilder;
    /** @param propertyName - Property whose value is compared with `string`.
     * @param string - String to compare against. Case-insensitive.
     */
    startsWith: (propertyName: 'label' | 'title', value: string) => CategoriesQueryBuilder;
    in: (propertyName: '_id' | 'label' | 'postCount' | 'title' | 'displayPosition' | 'translationId' | 'language' | 'slug' | 'internalId', value: any) => CategoriesQueryBuilder;
    exists: (propertyName: 'label' | 'title' | 'translationId' | 'language' | 'slug', value: boolean) => CategoriesQueryBuilder;
    /** @param propertyNames - Properties used in the sort. To sort by multiple properties, pass properties as additional arguments. */
    ascending: (...propertyNames: Array<'_id' | 'label' | 'postCount' | 'title' | 'displayPosition' | 'language' | 'slug'>) => CategoriesQueryBuilder;
    /** @param propertyNames - Properties used in the sort. To sort by multiple properties, pass properties as additional arguments. */
    descending: (...propertyNames: Array<'_id' | 'label' | 'postCount' | 'title' | 'displayPosition' | 'language' | 'slug'>) => CategoriesQueryBuilder;
    /** @param limit - Number of items to return, which is also the `pageSize` of the results object. */
    limit: (limit: number) => CategoriesQueryBuilder;
    /** @param skip - Number of items to skip in the query results before returning the results. */
    skip: (skip: number) => CategoriesQueryBuilder;
    find: () => Promise<CategoriesQueryResult>;
}
/**
 * Deletes a category.
 * @param categoryId - Category ID.
 * @public
 * @requiredField categoryId
 * @permissionId BLOG.DELETE-CATEGORY
 * @permissionScope Manage Blog
 * @permissionScopeId SCOPE.DC-BLOG.MANAGE-BLOG
 * @applicableIdentity APP
 * @fqn com.wixpress.npm.communities.platformized.blog.v3.CategoryService.DeleteCategory
 */
export declare function deleteCategory(categoryId: string): Promise<void>;
export {};
