"use strict";

exports.__esModule = true;
exports.getResponsiveImageProps = void 0;
var _max = require("../api/max");
const alignTypes = {
  CENTER: 'center',
  TOP: 'top',
  TOP_LEFT: 'top_left',
  TOP_RIGHT: 'top_right',
  BOTTOM: 'bottom',
  BOTTOM_LEFT: 'bottom_left',
  BOTTOM_RIGHT: 'bottom_right',
  LEFT: 'left',
  RIGHT: 'right'
};
const getCropDataWithAlign = (targetAspectRatio, originalAspectRatio, originalHeight, originalWidth, targetHeight, lowerWidth, bpWidth, alignType = alignTypes.CENTER) => {
  if (targetAspectRatio > originalAspectRatio) {
    // Image needs vertical cropping
    const width = originalWidth;
    const height = Math.round(originalWidth / (lowerWidth / targetHeight));
    let y = Math.round(originalHeight / 2 - height / 2);
    const x = 0;
    if (alignType.includes('top')) {
      y = 0;
    } else if (alignType.includes('bottom')) {
      y = originalHeight - height;
    }
    return {
      width,
      height,
      x,
      y
    };
  } else {
    // Image needs horizontal cropping
    const width = Math.round(originalHeight / (targetHeight / bpWidth));
    const height = originalHeight;
    let x = Math.round(originalWidth / 2 - width / 2);
    const y = 0;
    if (alignType.includes('left')) {
      x = 0;
    } else if (alignType.includes('right')) {
      x = originalWidth - width;
    }
    return {
      width,
      height,
      x,
      y
    };
  }
};
const WIDTHS = [1920, 1536, 1366, 1280, 980];
const getSources = (widthProportion, originalWidth, originalHeight, targetHeight, targetWidth, uri, quality, name, alignType, hasAnimation, upscaleMethod, focalPoint, crop, encoding, siteMargin, displayMode) => {
  const hasOriginalSizeDisplayMode = displayMode === 'original_size';
  const originalAspectRatio = originalWidth / originalHeight;
  return WIDTHS.map((width, index) => {
    const isLowestBreakpoint = width === 980;
    const getWidth = w => {
      if (isLowestBreakpoint) {
        return targetWidth;
      }
      return (w - 2 * (siteMargin || 0)) * (widthProportion / 100);
    };
    const lowerBpWidth = getWidth(WIDTHS[index + 1]);
    const currentBpWidth = getWidth(width);
    const targetAspectRatio = lowerBpWidth / targetHeight;
    const useManualCrop = !(hasOriginalSizeDisplayMode || isLowestBreakpoint);
    const manualCrop = useManualCrop && getCropDataWithAlign(targetAspectRatio, originalAspectRatio, originalHeight, originalWidth, targetHeight, lowerBpWidth, currentBpWidth, alignType);
    const {
      srcset,
      fallbackSrc,
      css
    } = getResponsiveImageProps({
      displayMode: hasOriginalSizeDisplayMode ? 'original_size' : isLowestBreakpoint ? 'fill' : 'fit',
      uri,
      width: originalWidth,
      height: originalHeight,
      crop: crop || manualCrop,
      name,
      focalPoint,
      alignType,
      quality,
      upscaleMethod,
      hasAnimation,
      encoding
    }, currentBpWidth, targetHeight);
    return {
      srcset,
      sizes: isLowestBreakpoint ? `${widthProportion}vw` : `${currentBpWidth}px`,
      media: `(max-width: ${width}px)`,
      fallbackSrc,
      imgStyle: css == null ? void 0 : css.img
    };
  });
};
const getResponsiveImageProps = (imageProps, targetWidth, targetHeight) => {
  const {
    displayMode,
    uri,
    width,
    height,
    name,
    crop,
    focalPoint,
    alignType,
    quality,
    upscaleMethod,
    hasAnimation,
    allowAnimatedTransform,
    encoding,
    siteMargin,
    widthProportion
  } = imageProps;
  if (!widthProportion) {
    var _srcset$dpr;
    const {
      srcset,
      css,
      uri: src
    } = (0, _max.getData)(displayMode, {
      id: uri,
      width,
      height,
      name,
      crop,
      focalPoint
    }, {
      width: targetWidth,
      height: targetHeight,
      alignment: alignType
    }, {
      focalPoint,
      name,
      quality: quality == null ? void 0 : quality.quality,
      upscaleMethod,
      hasAnimation,
      allowAnimatedTransform,
      useSrcset: true,
      encoding
    });
    const srcsetWithPrefix = srcset == null || (_srcset$dpr = srcset.dpr) == null ? void 0 : _srcset$dpr.map(s => /^[a-z]+:/.test(s) ? s : `${_max.STATIC_MEDIA_URL}${s}`);
    const fallbackSrc = `${_max.STATIC_MEDIA_URL}${src}`;
    const srcsetString = srcsetWithPrefix == null ? void 0 : srcsetWithPrefix.join(', ');
    return {
      fallbackSrc,
      srcset: srcsetString,
      css
    };
  } else {
    const sources = getSources(widthProportion, width, height, targetHeight, targetWidth, uri, quality, name, alignType, hasAnimation, upscaleMethod, focalPoint, crop, encoding, siteMargin, displayMode).filter(Boolean).reverse();
    return {
      fallbackSrc: sources[0].fallbackSrc,
      sources,
      css: sources[0].imgStyle
    };
  }
};
exports.getResponsiveImageProps = getResponsiveImageProps;
//# sourceMappingURL=responsiveImageUtils.js.map