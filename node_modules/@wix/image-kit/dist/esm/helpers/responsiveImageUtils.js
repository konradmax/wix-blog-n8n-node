import { getData, STATIC_MEDIA_URL } from '../api/max';
const alignTypes = {
    CENTER: 'center',
    TOP: 'top',
    TOP_LEFT: 'top_left',
    TOP_RIGHT: 'top_right',
    BOTTOM: 'bottom',
    BOTTOM_LEFT: 'bottom_left',
    BOTTOM_RIGHT: 'bottom_right',
    LEFT: 'left',
    RIGHT: 'right',
};
const getCropDataWithAlign = (targetAspectRatio, originalAspectRatio, originalHeight, originalWidth, targetHeight, lowerWidth, bpWidth, alignType = alignTypes.CENTER) => {
    if (targetAspectRatio > originalAspectRatio) {
        // Image needs vertical cropping
        const width = originalWidth;
        const height = Math.round(originalWidth / (lowerWidth / targetHeight));
        let y = Math.round(originalHeight / 2 - height / 2);
        const x = 0;
        if (alignType.includes('top')) {
            y = 0;
        }
        else if (alignType.includes('bottom')) {
            y = originalHeight - height;
        }
        return { width, height, x, y };
    }
    else {
        // Image needs horizontal cropping
        const width = Math.round(originalHeight / (targetHeight / bpWidth));
        const height = originalHeight;
        let x = Math.round(originalWidth / 2 - width / 2);
        const y = 0;
        if (alignType.includes('left')) {
            x = 0;
        }
        else if (alignType.includes('right')) {
            x = originalWidth - width;
        }
        return { width, height, x, y };
    }
};
const WIDTHS = [1920, 1536, 1366, 1280, 980];
const getSources = (widthProportion, originalWidth, originalHeight, targetHeight, targetWidth, uri, quality, name, alignType, hasAnimation, upscaleMethod, focalPoint, crop, encoding, siteMargin, displayMode) => {
    const hasOriginalSizeDisplayMode = displayMode === 'original_size';
    const originalAspectRatio = originalWidth / originalHeight;
    return WIDTHS.map((width, index) => {
        const isLowestBreakpoint = width === 980;
        const getWidth = (w) => {
            if (isLowestBreakpoint) {
                return targetWidth;
            }
            return (w - 2 * (siteMargin || 0)) * (widthProportion / 100);
        };
        const lowerBpWidth = getWidth(WIDTHS[index + 1]);
        const currentBpWidth = getWidth(width);
        const targetAspectRatio = lowerBpWidth / targetHeight;
        const useManualCrop = !(hasOriginalSizeDisplayMode || isLowestBreakpoint);
        const manualCrop = useManualCrop &&
            getCropDataWithAlign(targetAspectRatio, originalAspectRatio, originalHeight, originalWidth, targetHeight, lowerBpWidth, currentBpWidth, alignType);
        const { srcset, fallbackSrc, css } = getResponsiveImageProps({
            displayMode: hasOriginalSizeDisplayMode
                ? 'original_size'
                : isLowestBreakpoint
                    ? 'fill'
                    : 'fit',
            uri,
            width: originalWidth,
            height: originalHeight,
            crop: crop || manualCrop,
            name,
            focalPoint,
            alignType,
            quality,
            upscaleMethod,
            hasAnimation,
            encoding,
        }, currentBpWidth, targetHeight);
        return {
            srcset,
            sizes: isLowestBreakpoint
                ? `${widthProportion}vw`
                : `${currentBpWidth}px`,
            media: `(max-width: ${width}px)`,
            fallbackSrc,
            imgStyle: css?.img,
        };
    });
};
export const getResponsiveImageProps = (imageProps, targetWidth, targetHeight) => {
    const { displayMode, uri, width, height, name, crop, focalPoint, alignType, quality, upscaleMethod, hasAnimation, allowAnimatedTransform, encoding, siteMargin, widthProportion, } = imageProps;
    if (!widthProportion) {
        const { srcset, css, uri: src, } = getData(displayMode, { id: uri, width, height, name, crop, focalPoint }, {
            width: targetWidth,
            height: targetHeight,
            alignment: alignType,
        }, {
            focalPoint,
            name,
            quality: quality?.quality,
            upscaleMethod,
            hasAnimation,
            allowAnimatedTransform,
            useSrcset: true,
            encoding,
        });
        const srcsetWithPrefix = srcset?.dpr?.map((s) => /^[a-z]+:/.test(s) ? s : `${STATIC_MEDIA_URL}${s}`);
        const fallbackSrc = `${STATIC_MEDIA_URL}${src}`;
        const srcsetString = srcsetWithPrefix?.join(', ');
        return {
            fallbackSrc,
            srcset: srcsetString,
            css,
        };
    }
    else {
        const sources = getSources(widthProportion, width, height, targetHeight, targetWidth, uri, quality, name, alignType, hasAnimation, upscaleMethod, focalPoint, crop, encoding, siteMargin, displayMode)
            .filter(Boolean)
            .reverse();
        return {
            fallbackSrc: sources[0].fallbackSrc,
            sources,
            css: sources[0].imgStyle,
        };
    }
};
//# sourceMappingURL=responsiveImageUtils.js.map